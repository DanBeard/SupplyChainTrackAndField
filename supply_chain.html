<html>
<head>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P&display=swap" rel="stylesheet">
 <style>
     #gamecanvas {
         border:10px solid black; margin:auto;background: #87ceeb;
     }

 </style>
</head>

<body style="margin:0; padding:0; width:100%; height:100%; background: black">

<div id="container" style="height: 100%; width:100%;
    display: flex; align-content: center; align-items: center;


">
<canvas id="gamecanvas" width="1200" height="800" >

</canvas>
</div>

<audio id="sndtitle" src="sounds/title.mp3" loop autoplay hidden > </audio>
<audio id="sndbeep" src="sounds/beep.mp3" hidden > </audio>
<audio id="sndrun" src="sounds/run.mp3" loop hidden> </audio>
<audio id="sndgun" src="sounds/gun.mp3"  hidden> </audio>
<audio id="sndstart" src="sounds/start.mp3"  hidden> </audio>
<audio id="sndwin" src="sounds/win.mp3" hidden> </audio>
<audio id="sndlose" src="sounds/game_over.mp3"  hidden> </audio>
<audio id="speech" src="sounds/speech.mp3"  hidden> </audio>
<div style="display:none;">
    <img id="cpu"
         src="/sprites/cpu.png" />
    <img id="player1"
         src="/sprites/player1.png" />
    <img id="player2"
         src="/sprites/player1.png" />
    <img id="player3"
         src="/sprites/player1.png" />
    <img id="bg"
         src="/sprites/bg.png" />

    <img id="arrowUp"
         src="/sprites/ArrowUp.png" />
    <img id="arrowDown"
         src="/sprites/ArrowDown.png" />

    <img id="corman"
         src="/images/corman.jpg" />


</div>

<script>
    // helper and & "walkthrough" text
    const baseHelperText = ["Welcome to Supply Chain Sprint.",
        "The malicious 'red team' hacker needs to exploit a vulnerability",
        "Meanwhile the 'blue team' protectors need to run a relay race",
        "",
        "",
        "1st: Implementors need to develop a patch for the library",
        "2nd: Integrators need to include that patch in their program",
        "3rd: IT on site needs to update the library and apply it to the system"
    ];
    const cvdHelperText = ["_CVD cheat is active",
        "",
        "You have a Coordinated Vulnerability Disclosure (CVD) Program",
        "Blue team gets a head start on the patches before the Red Team",
        "can start developing an exploit for the vulnerability"
    ];
    const sbomHelperText = ["SBOM cheat is active",
        "",
        "You have an accurate Software Bill of Materials (SBOM) ",
        "This means Integrators and IT can start mitigating ASAP. ",
        "Blue team no longer runs a relay race. All players start at once"
    ];


    function init(){

        var canvasWidth = 1400;
        var canvasHeight = 800;
        var ctx = document.getElementById('gamecanvas').getContext('2d');
        const playerSprites = [
            document.getElementById('cpu'),
            document.getElementById('player1'),
            document.getElementById('player2'),
            document.getElementById('player3'),
        ];
        var bgSprites = document.getElementById('bg');
        var arrowUpSprite = document.getElementById("arrowUp");
        var arrowDownSprite = document.getElementById("arrowDown");

        var spriteScale = 2.5;

        var speechSnd = document.getElementById("speech");

        // SPRITE HELPER FUNCS
        function drawSprite(img, canvasX, canvasY, frameX, frameY, width, height, scale) {
            var scaledWidth = scale * width;
            var scaledHeight = scale * height;
            ctx.drawImage(img,
                frameX, frameY, width, height,
                canvasX, canvasY, scaledWidth, scaledHeight);
        }

        function drawPlayerSprite(playerIdx, state, canvasX, canvasY) {
            //[x,y,width]
            var sprite_info = {
                idle:  [0, 4, 19, 32],
                mark: [176, 4, 29, 32],
                set: [208, 4, 32, 32],
                run0:  [2, 40, 23, 32],
                run1:  [25, 40, 23, 32],
                run2:  [46, 40, 23, 32],
                run3:  [72, 40, 23, 32],
                run4:  [96, 45, 31, 28],
                run5:  [130, 41, 31, 32],
                win0: [108, 172, 25, 32],
                win1: [136, 172, 25, 32],
                lose0: [204, 172, 17, 32],
                lose1: [224, 172, 25, 32],


            };
            var info =  sprite_info[state];
            if(!info) return;
            var sprites = playerSprites[playerIdx];
            drawSprite(sprites, canvasX, canvasY,info[0], info[1], info[2], info[3], spriteScale);
        }

        function drawBgSprite(sprite, canvasX, canvasY) {
            var sprite_info = {
                track: [3, 0, 28, 41],
                finish: [88, 0, 21, 41],
                win: [112, 0, 21, 41],
                grass: [3, 51, 257, 24],
                wall: [91, 110, 28, 25],
                fans: [120, 110, 28, 22],
                fansFlash: [149, 110, 28, 22],

            };
            var info =  sprite_info[sprite];
            drawSprite(bgSprites, canvasX, canvasY,info[0], info[1], info[2], info[3], spriteScale);
        }

        const pixelToM = ~~(canvasWidth / 20); // about 20 meters per screen

        // draw the distance marker itself
        function drawMarker(text, x,y) {
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.rect(x-30, y, 60, 25);
            ctx.fill();
            // now the text
            ctx.font = "30px \"Lucida Console\", Monaco, monospace";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = 'alphabetic';
            ctx.fillText(text, x, y + 25);
        }

        // Draw the distance markers for a player (10, 20, 30, etc)
        function drawDistanceMarkers(playerState) {
            // draw the user's label
            drawMarker(playerState.name, 100, playerState.Y+60 );
            let x = ~~(playerState.X - 10*pixelToM);
            let distance = ~~(playerState.distance - 10); // start BEHIND the player so it doesnt dissppear
            let xShift = (playerState.distance - 10 - distance) * pixelToM; // shift the drawing for smooth animation in floating point distances
            while(x <= canvasWidth) {
                if(distance===playerState.maxDistance && playerState.finisher) {
                    if(playerState.distance >= playerState.maxDistance) {
                        drawBgSprite("win", x, playerState.Y);
                    } else {
                        drawBgSprite("finish", x, playerState.Y);
                    }
                }
                if(distance % 10 === 0 && distance > 0 ) {
                    drawMarker(distance, x - xShift, playerState.Y+78)
                }
                if(playerState.drawOtherPlayers) {
                    if(distance === state.player2.distance) drawPlayer(2, x, playerState.Y);
                    else if(distance === state.player3.distance) drawPlayer(3, x, playerState.Y);
                }
                distance++;
                x += pixelToM
            }
        }
        function drawBackground() {
            // draw the grass sprites
            const grassWidth=250*spriteScale;
            const wallWidth = 28*spriteScale; // also fan width
            const trackWidth =  25*spriteScale;


            let x = 0;
            let y= 0;

            x=0;
            while(x<=canvasWidth) {
                drawBgSprite("grass", x, state.cpu.Y );
                drawBgSprite("grass", x, state.player1.Y );
                drawBgSprite("grass", x, state.player2.Y );
                drawBgSprite("grass", x, state.player3.Y );
                drawBgSprite("grass", x, canvasHeight-75 );
                x+=grassWidth;
            }

            const wallY =  state.cpu.Y -50;
            x=0;
            while(x<canvasWidth) {
                drawBgSprite("fans", x, wallY-50);
                drawBgSprite("wall", x, wallY);
                x+=wallWidth;
            }

            // draw the tracks
            x=0;
            while(x <= canvasWidth) {

                drawBgSprite("track", x, state.cpu.Y );
                drawBgSprite("track", x, state.player1.Y);
                drawBgSprite("track", x, state.player2.Y);
                drawBgSprite("track", x, state.player3.Y);

                x += trackWidth;
            }

            // now draw the numbers for each player's tracks
            drawDistanceMarkers(state.cpu);
            drawDistanceMarkers(state.player1);
            drawDistanceMarkers(state.player2);
            drawDistanceMarkers(state.player3);

            // draw the sky text
            x=canvasWidth/2 -110; y=150;
            ctx.fillStyle = "black";
            ctx.strokeStyle = "blue";
            ctx.lineWidth = 5;
            ctx.beginPath();
            ctx.fillRect(x-300, y-100, 600, 150);
            ctx.strokeRect(x-300, y-100, 600, 150);
            // now the text
            ctx.font = "30px \"Press Start 2P\", Monaco, monospace";
            ctx.fillStyle = "white";

            ctx.textAlign = "center";
            ctx.textBaseline = 'alphabetic';
            for(let i=0; i<state.game.skyText.length; i++ ) {
                ctx.fillText(state.game.skyText[i], x, y - 50 );
                y+=50;
            }

        }

        //STATE
        let framenum = 0;
                    // base, run, ahead, final
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ_";


        let state = {
            game : {
                state : "menu",  //menu, , idle, prep, game, lose, win, end
                players: 3, // number of players
                cpuHeadStart: 100, // ms of head start before the CPU starts
                autoplay: false,
                cheatsActive: [""],
                skyText : ["Supply Chain Sprint", "Typical Process", ""],
                menu : {
                   whichMenu: "main", // main, cheats, helper
                   selectedIdx: 0, // which row is selected
                   selectedCol: 0, // which COLUMN is selected (for cheat codes)
                   blinkSelection: true,
                   currentCheat: ["A","A","A","A"], // the current cheat code to enter

                    cheatStatus: "", // for "CHEAT accepted" or "CHEAT DENIED"

                    helper: {
                        text : [baseHelperText], // each string is it's own page
                        pos: 0, // position of the helper text to draw
                        page: 0 // the PAGE that we're on (idx into helperText)
                    }

                }
            },
            cpu : {
                X: 250,  // the x where the player WILL be drawn
                targetX: 250, // the X where we WANT the player drawn
                Y: 320, // hard coded Y values, since... they never change
                name: "HAX",
                action: "idle", // idle, mark, set or running
                runAnimCounter: 0, // which frame of runANim to use if rnning
                distance: 0, //"distance" player has run in like, meters or something.
                maxDistance: 100,
                finisher: true, // if finished will the win?
                drawOtherPlayers: false,
                canRun: false
            },
            player1 : {
                X: 250,
                targetX: 250, // the X where we WANT the player drawn
                Y: 420, // hard coded Y values, since... they never change
                name: "IMPL",
                action: "idle", // idle, mark, set or running
                runAnimCounter: 0, // which frame of runANim to use if rnning
                distance: 0, //"distance" player has run in like, meters or something.
                maxDistance: 100,
                finisher: false, // if finished will the win?
                buttonPushed: true, // if true, they will try and run, if false, then no
                canRun:true, // if true, then this player can run the relay race
                drawOtherPlayers: true
            },
            player2 : {
                X: 250,
                targetX: 250, // the X where we WANT the player drawn
                Y: 520, // hard coded Y values, since... they never change
                name: "INT",
                action: "idle", // idle, mark, set or running
                runAnimCounter: 0, // which frame of runANim to use if rnning
                distance: 100, //"distance" player has run in like, meters or something.
                maxDistance: 200,
                finisher: false, // if finished will the win?
                buttonPushed: true, // if true, they will try and run, if false, then no
                canRun:false,
                drawOtherPlayers: true
            },
            player3 : {
                X: 250,
                targetX: 250, // the X where we WANT the player drawn
                Y: 620, // hard coded Y values, since... they never change
                name: "IT",
                action: "idle", // idle, mark, set or running
                runAnimCounter: 0, // which frame of runANim to use if rnning
                distance: 200, //"distance" player has run in like, meters or something.
                maxDistance: 300,
                finisher: true, // if finished will the win?
                buttonPushed: true, // if true, they will try and run, if false, then no
                canRun: false,
                drawOtherPlayers: false
            },
        };
        const initialState = JSON.parse(JSON.stringify(state));
        document.state = state; // for easy tweaking.
        //deep copy initial state
        document.initialState = initialState;


        // DRAW HELPER FUNCS
        const playerNames = ["cpu","player1","player2","player3"];
        function drawPlayer(playernum, overrideX, overrideY){
            const playername = playerNames[playernum];
            const playerState = state[playername];
            const X = overrideX ? overrideX : playerState.X;
            const Y = overrideY ? overrideY : playerState.Y;
            if(playerState.action === "running") {
                drawPlayerSprite(playernum, "run"+playerState.runAnimCounter, X, Y);
                playerState.runAnimCounter = (playerState.runAnimCounter + 1) % 6; // wrap around
            }
            else if(playerState.action === "win" || playerState.action === "lose") {
                let animCount = ~~((framenum % 4) /2);
                drawPlayerSprite(playernum, playerState.action+animCount, X,Y);

            }
            else {
                drawPlayerSprite(playernum, playerState.action, X, Y);
            }
        }

        function drawPlayerFinishLine(playerState, onend) {
            //running through finish line animation
            var intervalHandle = setInterval(()=>{
                playerState.X += 10;
                playerState.targetX = playerState.X;
                playerState.distance += 0.1;
                if(playerState.X >= 900) {
                    clearInterval(intervalHandle);
                    if(onend) onend();
                }
            }, 80);

        }

        function drawMenu(framenum) {
            ctx.fillStyle = "#1A1A1A";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            switch(state.game.menu.whichMenu) {
                /*****************
                 *   MAIN MENU   *
                 ****************/
                case "main": {
                    // selectedIdx sanity checks
                    if(state.game.menu.selectedIdx < 0) state.game.menu.selectedIdx = 0;
                    else if(state.game.menu.selectedIdx > 2) state.game.menu.selectedIdx = 2;

                    const middle = canvasWidth / 2 - 110;
                    ctx.font = "50px \"Press Start 2P\", Monaco, monospace";
                    ctx.fillStyle = "white";
                    ctx.textBaseline = 'middle';
                    ctx.textAlign = 'center';
                    ctx.fillText("Supply Chain",middle, 200);
                    ctx.fillText("Sprint", middle, 300);

                    ctx.font = "30px \"Press Start 2P\", Monaco, monospace";
                    // for the flashing effect, we will change the fill color to black
                    ctx.fillStyle = "white";
                    if(state.game.menu.blinkSelection && state.game.menu.selectedIdx === 0) ctx.fillStyle = "#1A1A1A";
                    ctx.fillText("1 Player", middle, 450);
                    ctx.fillStyle = "white";
                    if(state.game.menu.blinkSelection && state.game.menu.selectedIdx === 1) ctx.fillStyle = "#1A1A1A";
                    ctx.fillText("3 Player", middle, 500);
                    ctx.fillStyle = "white";
                    if(state.game.menu.blinkSelection && state.game.menu.selectedIdx === 2) ctx.fillStyle = "#1A1A1A";
                    ctx.fillText("Cheat Codes", middle, 550);

                    ctx.fillStyle = "white";
                    ctx.font = "20px \"Press Start 2P\", Monaco, monospace";
                    ctx.textAlign = 'left';
                    ctx.fillText("Coding: Daniel Beard", 50, 725);
                    ctx.textAlign = 'right';
                    ctx.fillText("Inspiration: Josh Corman ", canvasWidth - 220, 725);
                break;
                }
                /*****************
                 *   CHEATS MENU *
                 ****************/
                case "cheats":{
                    // selectedCol sanity checks
                    if(state.game.menu.selectedCol < -1) state.game.menu.selectedCol = -1;
                    else if(state.game.menu.selectedCol > 3) state.game.menu.selectedCol = 3;

                    // cheat letter select logic
                    if(state.game.menu.selectedIdx !== 0) {
                        let col = state.game.menu.selectedCol;
                        let letter = alphabet.indexOf(state.game.menu.currentCheat[col]);
                        letter = letter + state.game.menu.selectedIdx;
                        state.game.menu.selectedIdx = 0; // reset to 0
                        if(letter < 0) letter = alphabet.length - 1; // negative wrap around
                        else if(letter >= alphabet.length) letter = letter % alphabet.length; // positive wrap around
                        // set the letter in the cheat code
                        state.game.menu.currentCheat[col] = alphabet[letter];
                    }
                    ctx.font = "50px \"Press Start 2P\", Monaco, monospace";
                    ctx.fillStyle = "white";
                    ctx.textBaseline = 'middle';
                    ctx.textAlign = 'center';
                    if(state.game.menu.blinkSelection && state.game.menu.selectedCol === -1) ctx.fillStyle = "#1A1A1A";
                    ctx.fillText("BACK", 150, 100);
                    const currentCheat = state.game.menu.currentCheat;

                    ctx.fillStyle = "white";
                    if(state.game.menu.selectedCol === 0) {
                        drawSprite(arrowUpSprite, 425, 115, 0, 0, 180, 190, 0.5);
                        drawSprite(arrowDownSprite, 425, 230, 0, 0, 180, 190, 0.5);
                        if(state.game.menu.blinkSelection) ctx.fillStyle = "#1A1A1A";
                    }
                    ctx.fillText(currentCheat[0], 450, 200);

                    ctx.fillStyle = "white";
                    if(state.game.menu.selectedCol === 1){
                        drawSprite(arrowUpSprite, 525, 115, 0, 0, 180, 190, 0.5);
                        drawSprite(arrowDownSprite, 525, 230, 0, 0, 180, 190, 0.5);
                        if(state.game.menu.blinkSelection) ctx.fillStyle = "#1A1A1A";
                    }
                    ctx.fillText(currentCheat[1], 550, 200);

                    ctx.fillStyle = "white";
                    if(state.game.menu.selectedCol === 2){
                        drawSprite(arrowUpSprite, 625, 115, 0, 0, 180, 190, 0.5);
                        drawSprite(arrowDownSprite, 625, 230, 0, 0, 180, 190, 0.5);
                        if(state.game.menu.blinkSelection) ctx.fillStyle = "#1A1A1A";
                    }
                    ctx.fillText(currentCheat[2], 650, 200);

                    ctx.fillStyle = "white";
                    if(state.game.menu.selectedCol === 3){
                        drawSprite(arrowUpSprite, 725, 115, 0, 0, 180, 190, 0.5);
                        drawSprite(arrowDownSprite, 725, 230, 0, 0, 180, 190, 0.5);
                        if(state.game.menu.blinkSelection) ctx.fillStyle = "#1A1A1A";
                    }

                    ctx.fillText(currentCheat[3], 750, 200);

                    ctx.fillStyle = "white";
                    ctx.textAlign = 'left';
                    ctx.fillText(state.game.menu.cheatStatus, 250, 400);

                    ctx.font = "20px \"Press Start 2P\", Monaco, monospace";

                    ctx.fillText("Try the following Cheat Codes: ", 150, 500);
                    ctx.fillText("_CVD  = Coordinated Vulnerability Disclosure", 200, 550);
                    ctx.fillText("SBOM  = Software Bill of Materials", 200, 600);

                }
                break;
                /*****************
                 *   HELPER MENU *
                 ****************/
                case "intro": {
                    ctx.drawImage(document.getElementById("corman"), 50, 30);
                    ctx.font = "15px \"Press Start 2P\", Monaco, monospace";
                    ctx.fillStyle = "white";
                    ctx.textAlign = 'left';
                    const helper = state.game.menu.helper;
                    // if we've gone past the helper text
                    if(helper.page >= helper.text.length) {
                        helper.page = 0;
                        startGame(state);
                        return;
                    }
                    const  text = helper.text[helper.page];
                    let Y = 300;
                    let pos = ~~(helper.pos);

                    for(let i=0; i< text.length && pos >=0; i++) {
                        ctx.fillText(text[i].slice(0, pos), 50, Y);
                        pos -= text[i].length;
                        Y+=50;
                    }

                    // advance
                    helper.pos+=2;
                    // only play snd if we actually 'typed' something
                    if(pos <=0) {
                        speechSnd.play();
                    }
                    // auto advance after a time if in autoplay or after a LONG time in normal mode
                    else if ((pos > 100 && state.game.autoplay) || pos > 5000) {
                        helper.page++;
                        helper.pos = 0;
                    }

                }
                break;
            }

        }

        //AUTO PLAY HELPERS
        // cheat order for autoplay
        // This can't be in the main state object because it must survive resets
        const autoplayCheatOrder = [
            null,
            ["_", "C", "V", "D"],
            ["S", "B", "O", "M"],
        ];
        let lastAutoplayCheat=0;
        // BIG 'OL PRESS START for autoplay
        function drawAutoPlay() {
            const x = canvasWidth/2 -110;
            const y = canvasHeight/2 + 50;
            const text = "PRESS START TO PLAY";

            ctx.font = "30px \"Press Start 2P\", Monaco, monospace";
            ctx.fillStyle = "black";
            ctx.textAlign = "center";
            ctx.textBaseline = 'middle';
            ctx.fillText(text, x, y);
        }

        // MAIN DRAW FUNC
        function draw() {
            framenum++;
            framenum = framenum % 1000; // 1000 options to slow frames down
            // schedule nex draw
            window.requestAnimationFrame(draw);

            // let anything that needs to blink know that it's time to blink
            if(framenum % 50 === 0) state.game.menu.blinkSelection = !state.game.menu.blinkSelection;

            // autplay draw logic
            // autoplay logic
            if(state.game.autoplay) {
                // everyone runs at half speed in autoplay
                setAllPlayerStates("buttonPushed", framenum % 2 === 0);
                // if we're in the main menu, enable a cheat and start the game
                if(state.game.state === "menu" && state.game.menu.whichMenu === "main") {
                    let cheat = autoplayCheatOrder[lastAutoplayCheat++ % autoplayCheatOrder.length];
                    if(cheat) {
                        state.game.menu.whichMenu = "cheats";
                        state.game.menu.currentCheat = cheat;
                        selectionMade(state);
                    }
                    // now start the game
                    setTimeout(()=> state.game.menu.whichMenu = "intro", 1);

                } else if(state.game.state === "end") {
                    // temporary state to give some delay
                    state.game.state = "resetting";
                    setTimeout(()=> {
                        state.game.state="reset"
                    }, 5000);
                }
            }
            // menu draw logic
            if(state.game.state === "menu" && framenum % 5 === 0) {
                gamepadLogic();

                ctx.clearRect(0, 0, canvasWidth, canvasHeight); // clear canvas
                drawMenu(framenum);
                if(document.drawCrt) document.drawCrt();
            }
            // game draw logic
            if(state.game.state !== "menu" && framenum % 3 === 0) {
                //draw logic
                gamepadLogic();
                ctx.clearRect(0, 0, canvasWidth, canvasHeight); // clear canvas

                    drawBackground();
                    drawPlayer(0);
                    drawPlayer(1);
                    drawPlayer(2);
                    drawPlayer(3);
                if(state.game.autoplay) {
                    // blink the "PRESS START TO PLAY"
                    if (state.game.menu.blinkSelection) drawAutoPlay(framenum);
                }

                if(document.drawCrt) document.drawCrt();

                // Game logic
                if(state.game.state === "game") {


                    // smooth animaton
                    if(state.cpu.targetX > state.cpu.X) state.cpu.X+=15;
                    else if(state.cpu.targetX < state.cpu.X) state.cpu.X--;

                    if(state.player1.targetX > state.player1.X) state.player1.X+=15;
                    else if(state.player1.targetX < state.player1.X) state.player1.X--;

                    if(state.player2.targetX > state.player2.X) state.player2.X+=15;
                    else if(state.player2.targetX < state.player2.X) state.player2.X--;

                    if(state.player3.targetX > state.player3.X) state.player3.X+=15;
                    else if(state.player3.targetX < state.player3.X) state.player3.X--;

                    const cpuDistLeft = (state.cpu.maxDistance - state.cpu.distance);

                    //move player if buttons pushed
                    if(state.player1.canRun && state.player1.distance < state.player1.maxDistance) {
                        if(state.player1.buttonPushed) state.player1.distance +=0.70;
                        state.player1.distance +=0.05;
                        state.player1.targetX = (state.player1.maxDistance - state.player1.distance) < cpuDistLeft ? 750 : 250 ;
                        state.player1.action = "running";
                        state.player1.buttonPushed = false;

                    }

                    if(state.player2.canRun && state.player2.distance < state.player2.maxDistance) {
                        if(state.player2.buttonPushed) state.player2.distance +=0.50;
                        state.player2.distance +=0.10;
                        state.player2.targetX = (state.player2.maxDistance - state.player2.distance) < cpuDistLeft ? 750 : 250 ;
                        state.player2.action = "running";
                        state.player2.buttonPushed = false;

                    }

                    if(state.player3.canRun && state.player3.distance < state.player3.maxDistance) {
                        if(state.player3.buttonPushed) state.player3.distance +=0.50;
                        state.player3.distance +=0.10;
                        state.player3.targetX = (state.player3.maxDistance - state.player3.distance) < cpuDistLeft ? 750 : 250 ;
                        state.player3.action = "running";
                        state.player3.buttonPushed = false;
                    }

                    //move CPU
                    if(state.cpu.canRun && state.cpu.distance < state.cpu.maxDistance) state.cpu.distance +=0.20;
                    //lose condition
                    else if(state.cpu.distance >= state.cpu.maxDistance) state.game.state = "lose";
                    //only win if player 3 is at the max
                    if(state.player3.distance >= state.player3.maxDistance) state.game.state = "win";

                    //stop player 1 and player 2 if they're at max distance, no run animation
                    if(state.player1.canRun && state.player1.distance >= state.player1.maxDistance)  {
                        state.player1.canRun = false;
                        drawPlayerFinishLine(state.player1, ()=> state.player1.action = "idle");
                        state.player2.canRun = true; // relay off to player 2
                    }
                    if( state.player2.canRun && state.player2.distance >= state.player2.maxDistance)  {
                        state.player2.canRun = false;
                        drawPlayerFinishLine(state.player2, ()=> state.player2.action = "idle");
                        state.player3.canRun = true; // relay off to player 3
                    }
                }
                else if(state.game.state === "lose") {

                    drawPlayerFinishLine(state.cpu, ()=> {
                        state.cpu.action = "win";
                        state.game.state = "end";
                    });

                    document.getElementById("sndlose").play();
                    setAllPlayerStates("action", "lose");
                    state.cpu.action = "running"; // he's still running thru the finish line
                    document.getElementById("sndrun").pause();
                    state.game.skyText[2] = "YOU LOSE!";

                }
                else if (state.game.state === "win") {
                    drawPlayerFinishLine(state.player3, ()=> {
                        state.player1.action = "win";
                        state.player2.action = "win";
                        state.player3.action = "win";
                        state.game.state = "end";
                    });
                    document.getElementById("sndwin").play();
                    setAllPlayerStates("action", "win");
                    //except CPU who loses
                    state.cpu.action = "lose";
                    state.player3.action = "running";

                    document.getElementById("sndrun").pause();
                    state.game.skyText[2] = "YOU WIN!";
                }
                else if(state.game.state === "reset") {
                    // autoplay should survive reset
                    let autoplay = state.game.autoplay;
                    state = JSON.parse(JSON.stringify(initialState));
                    document.state = state;
                    state.game.autoplay = autoplay;
                }
            }

        }

        draw();

    }

    init();

    // logic for starting the game itself
    function startGame(state) {
        state.game.state = "prep";
        document.getElementById("sndtitle").pause();
        document.getElementById("sndstart").play();
        setTimeout(()=>{ setAllPlayerStates("action", "mark"); document.getElementById("sndbeep").play(); }, 6000);
        setTimeout(()=>{ setAllPlayerStates("action", "set"); document.getElementById("sndbeep").play(); }, 8000);
        setTimeout(()=>{
            setTimeout(()=> {
                state.cpu.action="running"; // CPU is LIGHTNING FAST
                state.cpu.targetX= 500; // CPU is LIGHTNING FAST
                state.cpu.canRun = true;
            }, state.game.cpuHeadStart);
            state.game.state = "game";
            document.getElementById("sndgun").play();
            setTimeout(()=>document.getElementById("sndrun").play(), 500);
        }, 10000);
    }
    // logic for selection made in the menus (e.g. A button pushed)
    function selectionMade(state) {
        if(state.game.state === "menu") {
            if(state.game.menu.whichMenu === "main"){
                switch(state.game.menu.selectedIdx) {
                    case 0:
                        state.game.players = 1;
                        state.game.menu.whichMenu = "intro";
                    break;
                    case 1:
                        state.game.players = 3;
                        state.game.whichMenu = "intro";
                    break;
                    case 2:
                        state.game.menu.whichMenu = "cheats";
                        state.game.menu.currentCheat =  ["A","A","A","A"];
                        state.game.menu.selectedCol = 0;
                        state.game.menu.selectedIdx = 0;
                        return;
                }
            }
            else if(state.game.menu.whichMenu === "cheats"){
                if(state.game.menu.selectedCol === -1) {
                    state.game.menu.whichMenu = "main";
                    state.game.menu.selectedCol = 0;
                    state.game.menu.selectedIdx = 0;
                } else {
                    // CHEATS LOGIC
                    const currentCode = state.game.menu.currentCheat.join("");
                    let succ = false;
                    switch(currentCode){
                        case "_CVD":
                            succ = true;
                            state.game.cpuHeadStart = 19000;
                            // treat the text array as immutable so reset works
                            state.game.menu.helper.text = state.game.menu.helper.text.concat([cvdHelperText]);
                            state.game.cheatsActive.push("_CVD");
                            state.game.skyText[1] = "CVD Process";
                        break;
                        case "SBOM":
                            succ = true;
                            setAllPlayerStates("canRun", true);
                            setAllPlayerStates("finisher", true);
                            // treat the text array as immutable so reset works
                            state.game.menu.helper.text = state.game.menu.helper.text.concat([sbomHelperText]);
                            state.game.cheatsActive.push("SBOM");
                            state.game.skyText[1] = "SBOM Process";
                        break;
                    }
                    if(succ) state.game.menu.cheatStatus = currentCode + " SUCCESS ";
                    else state.game.menu.cheatStatus = currentCode + " FAILED ";
                }
            }
            else if(state.game.menu.whichMenu === "intro") {
                state.game.menu.helper.page++;
            }
        }
    }

    function setAllPlayerStates(key, val) {
        document.state.cpu[key] = val;
        document.state.player1[key] = val;
        document.state.player2[key] = val;
        document.state.player3[key] = val;
    }
    document.addEventListener('keydown', function(event) {
        const state = document.state;
        console.log(event.key);
        lastGamepadTimestamp = event.timeStamp;
       switch(event.key) {
         case " ":
             if(state.game.state === "idle") {
                 startGame(state);
             } else if(state.game.state === "end") {
                    state.game.state = "reset";
                    document.getElementById("sndtitle").play();
             }
         break;
             case "ArrowUp":
                 state.game.menu.selectedIdx--;
             break;
             case "ArrowDown":
                 state.game.menu.selectedIdx++;
             break;
           case "ArrowLeft":
               state.game.menu.selectedCol--;
               break;
           case "ArrowRight":
               state.game.menu.selectedCol++;
               break;
             case "Enter":
                 selectionMade(state);
             break;

       }
    });

    //gamepad support
    window.addEventListener("gamepadconnected", (event) => {
        console.log("A gamepad connected:");
        console.log(event.gamepad);
    });

    // Button pushing logic
    let buttonLastStatus = [Array(16).fill(false), Array(16).fill(false), Array(16).fill(false)];
    let lastRunButtonPushed = ["B","B","B"];
    let lastGamepadTimestamp = 0;
    function gamepadLogic() {
        var gamepads = navigator.getGamepads();
        // store the timestamp and save the cycles if nothing's changed
        let newButton =  false;
        for(let i=0; i< gamepads.length; i++) {
            if(gamepads[i]) {
                if(gamepads[i].timestamp > lastGamepadTimestamp) {
                    newButton = true;
                    lastGamepadTimestamp = gamepads[i].timestamp
                }
            }
        }
        if(!newButton) return;
        // a button is "pushed" if it's last status was true(depressed) but is now false (released)
        // in this way we only react when your finger is taken off of the button
        let buttonsPushed = [Array(16).fill(false), Array(16).fill(false), Array(16).fill(false)];


        let state = document.state;
        for(let i=0; i<3; i++)  {
            if(gamepads[i] && gamepads[i].buttons){
                for(let j=0; j<16; j++) {
                    // see above note for logic with buttojn "pushing"
                    if(gamepads[i].buttons[j]) {
                        if( buttonLastStatus[i][j] && !gamepads[i].buttons[j].pressed) buttonsPushed[i][j] = true;
                        buttonLastStatus[i][j] = gamepads[i].buttons[j].pressed;

                    }
                }
                //hacking together axis if that is the directions instead of DPAD
                if(gamepads[i].axes[1] === -1) buttonLastStatus[i][12] = true;
            }
        }

        // autoplay. If start is ever pushed, turn autoplay off
        if(buttonsPushed[0][9] && state.game.autoplay){
            state.game.autoplay = false;
            state.game.state = "reset";
        }

        //P1 menu selection logic
        if(state.game.state === "menu") {
            // B button
            if(buttonsPushed[0][0]) state.game.menu.whichMenu = "main"; // back to main menu
            // A button
            else if(buttonsPushed[0][1]) selectionMade(state);
            // up DPAD
            else if(buttonsPushed[0][12]) state.game.menu.selectedIdx--;
            // down DPAD
            else if(buttonsPushed[0][13]) state.game.menu.selectedIdx++;
            // left DPAD
            else if(buttonsPushed[0][14]) state.game.menu.selectedCol--;
            // right DPAD
            else if(buttonsPushed[0][15]) state.game.menu.selectedCol++;

        }
        // game reset button push logic (Push start to reset)
        else if(state.game.state === "end") {
            //reset
            for(let i=0; i<3; i++) {
                // start button
                if (buttonsPushed[i][9]) {
                    state.game.state = "reset";
                    document.getElementById("sndtitle").play();
                }
            }
        // in-game running logic (alternate A and B to run faster)
        }  else {

            for(let i=0; i<3; i++) {

                if(buttonsPushed[i][0]) {
                    if(lastRunButtonPushed[i] === "A") setAllPlayerStates("buttonPushed", true);
                    lastRunButtonPushed[i] = "B";
                    console.log("b")
                }
                else if(buttonsPushed[i][1]) {
                    if(lastRunButtonPushed[i] === "B") setAllPlayerStates("buttonPushed", true);
                    lastRunButtonPushed[i] = "A";
                    console.log("A")
                }
            }
        }

    }

    function autoplayTrigger() {
        const now = performance.now();
        if(now - lastGamepadTimestamp > 15000) {
            document.state.game.autoplay = true;
        }
    }

    setInterval(autoplayTrigger, 5000);

</script>
<!-- CRT screen effect -->
<script src="js/glfx.js"> </script>
<script src="js/crt.js"> </script>

</body>
</html>
