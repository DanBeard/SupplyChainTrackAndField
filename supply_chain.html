<html>
<head>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P&display=swap" rel="stylesheet">
 <style>
     #gamecanvas {
         border:10px solid black; margin:auto;background: #87ceeb;
     }

 </style>
</head>

<body style="margin:0; padding:0; width:100%; height:100%; background: black">

<div id="container" style="height: 100%; width:100%;
    display: flex; align-content: center; align-items: center;


">
<canvas id="gamecanvas" width="1200" height="800" >

</canvas>
</div>

<audio id="sndtitle" src="sounds/title.mp3" loop autoplay hidden > </audio>
<audio id="sndbeep" src="sounds/beep.mp3" hidden > </audio>
<audio id="sndrun" src="sounds/run.mp3" loop hidden> </audio>
<audio id="sndgun" src="sounds/gun.mp3"  hidden> </audio>
<audio id="sndstart" src="sounds/start.mp3"  hidden> </audio>
<audio id="sndwin" src="sounds/win.mp3" hidden> </audio>
<audio id="sndlose" src="sounds/game_over.mp3"  hidden> </audio>
<div style="display:none;">
    <img id="cpu"
         src="/sprites/cpu.png" />
    <img id="player1"
         src="/sprites/player1.png" />
    <img id="player2"
         src="/sprites/player1.png" />
    <img id="player3"
         src="/sprites/player1.png" />
    <img id="bg"
         src="/sprites/bg.png" />

    <img id="arrowUp"
         src="/sprites/ArrowUp.png" />
    <img id="arrowDown"
         src="/sprites/ArrowDown.png" />


</div>

<script>

    function init(){

        var canvasWidth = 1400;
        var canvasHeight = 800;
        var ctx = document.getElementById('gamecanvas').getContext('2d');
        const playerSprites = [
            document.getElementById('cpu'),
            document.getElementById('player1'),
            document.getElementById('player2'),
            document.getElementById('player3'),
        ];
        var bgSprites = document.getElementById('bg');
        var arrowUpSprite = document.getElementById("arrowUp");
        var arrowDownSprite = document.getElementById("arrowDown");

        var spriteScale = 2.5;

        // SPRITE HELPER FUNCS
        function drawSprite(img, canvasX, canvasY, frameX, frameY, width, height, scale) {
            var scaledWidth = scale * width;
            var scaledHeight = scale * height;
            ctx.drawImage(img,
                frameX, frameY, width, height,
                canvasX, canvasY, scaledWidth, scaledHeight);
        }

        function drawPlayerSprite(playerIdx, state, canvasX, canvasY) {
            //[x,y,width]
            var sprite_info = {
                idle:  [0, 4, 19, 32],
                mark: [176, 4, 29, 32],
                set: [208, 4, 32, 32],
                run0:  [2, 40, 23, 32],
                run1:  [25, 40, 23, 32],
                run2:  [46, 40, 23, 32],
                run3:  [72, 40, 23, 32],
                run4:  [96, 45, 31, 28],
                run5:  [130, 41, 31, 32],
                win0: [108, 172, 25, 32],
                win1: [136, 172, 25, 32],
                lose0: [204, 172, 17, 32],
                lose1: [224, 172, 25, 32],


            };
            var info =  sprite_info[state];
            var sprites = playerSprites[playerIdx];
            drawSprite(sprites, canvasX, canvasY,info[0], info[1], info[2], info[3], spriteScale);
        }

        function drawBgSprite(sprite, canvasX, canvasY) {
            var sprite_info = {
                track: [3, 0, 28, 41],
                finish: [88, 0, 21, 41],
                win: [112, 0, 21, 41],
                grass: [3, 51, 257, 24],
                wall: [91, 110, 28, 25],
                fans: [120, 110, 28, 22],
                fansFlash: [149, 110, 28, 22],

            };
            var info =  sprite_info[sprite];
            drawSprite(bgSprites, canvasX, canvasY,info[0], info[1], info[2], info[3], spriteScale);
        }

        const pixelToM = ~~(canvasWidth / 20); // about 20 meters per screen

        // draw the distance marker itself
        function drawMarker(text, x,y) {
            ctx.fillStyle = "black";
            ctx.beginPath();
            ctx.rect(x-30, y, 60, 25);
            ctx.fill();
            // now the text
            ctx.font = "30px \"Lucida Console\", Monaco, monospace";
            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = 'alphabetic';
            ctx.fillText(text, x, y + 25);
        }

        // Draw the distance markers for a player (10, 20, 30, etc)
        function drawDistanceMarkers(playerState) {
            // draw the user's label
            drawMarker(playerState.name, 100, playerState.Y+60 );
            let x = ~~(playerState.X - 10*pixelToM);
            let distance = ~~(playerState.distance - 10); // start BEHIND the player so it doesnt dissppear
            let xShift = (playerState.distance - 10 - distance) * pixelToM; // shift the drawing for smooth animation in floating point distances
            while(x <= canvasWidth) {
                if(distance===playerState.maxDistance && playerState.finisher) {
                    if(playerState.distance >= playerState.maxDistance) {
                        drawBgSprite("win", x, playerState.Y);
                    } else {
                        drawBgSprite("finish", x, playerState.Y);
                    }
                }
                if(distance % 10 === 0 && distance > 0 ) {
                    drawMarker(distance, x - xShift, playerState.Y+78)
                }
                if(playerState.drawOtherPlayers) {
                    if(distance === state.player2.distance) drawPlayer(2, x, playerState.Y);
                    else if(distance === state.player3.distance) drawPlayer(3, x, playerState.Y);
                }
                distance++;
                x += pixelToM
            }
        }
        function drawBackground() {
            // draw the grass sprites
            const grassWidth=250*spriteScale;
            const wallWidth = 28*spriteScale; // also fan width
            const trackWidth =  25*spriteScale;


            let x = 0;

            x=0;
            while(x<=canvasWidth) {
                drawBgSprite("grass", x, state.cpu.Y );
                drawBgSprite("grass", x, state.player1.Y );
                drawBgSprite("grass", x, state.player2.Y );
                drawBgSprite("grass", x, state.player3.Y );
                drawBgSprite("grass", x, canvasHeight-75 );
                x+=grassWidth;
            }

            const wallY =  state.cpu.Y -50;
            x=0;
            while(x<canvasWidth) {
                drawBgSprite("fans", x, wallY-50);
                drawBgSprite("wall", x, wallY);
                x+=wallWidth;
            }

            // draw the tracks
            x=0;
            while(x <= canvasWidth) {

                drawBgSprite("track", x, state.cpu.Y );
                drawBgSprite("track", x, state.player1.Y);
                drawBgSprite("track", x, state.player2.Y);
                drawBgSprite("track", x, state.player3.Y);

                x += trackWidth;
            }

            // now draw the numbers for each player's tracks
            drawDistanceMarkers(state.cpu);
            drawDistanceMarkers(state.player1);
            drawDistanceMarkers(state.player2);
            drawDistanceMarkers(state.player3);
        }

        //STATE
        let framenum = 0;
                    // base, run, ahead, final
        const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ_";

        let state = {
            game : {
                state : "menu",  //menu, idle, prep, game, lose, win, end
                players: 3, // number of players
                cpuHeadStart: 100, // ms of head start before the CPU starts
                menu : {
                   whichMenu: "main", // main, cheats
                   selectedIdx: 0, // which row is selected
                   selectedCol: 0, // which COLUMN is selected (for cheat codes)
                   blinkSelection: true,
                   currentCheat: ["A","A","A","A"], // the current cheat code to enter

                    cheatStatus: "" // for "CHEAT accepted" or "CHEAT DENIED"
                }
            },
            cpu : {
                X: 250,  // the x where the player WILL be drawn
                targetX: 250, // the X where we WANT the player drawn
                Y: 320, // hard coded Y values, since... they never change
                name: "HAX",
                action: "idle", // idle, mark, set or running
                runAnimCounter: 0, // which frame of runANim to use if rnning
                distance: 0, //"distance" player has run in like, meters or something.
                maxDistance: 100,
                finisher: true, // if finished will the win?
                drawOtherPlayers: false,
                canRun: false
            },
            player1 : {
                X: 250,
                targetX: 250, // the X where we WANT the player drawn
                Y: 420, // hard coded Y values, since... they never change
                name: "IMPL",
                action: "idle", // idle, mark, set or running
                runAnimCounter: 0, // which frame of runANim to use if rnning
                distance: 0, //"distance" player has run in like, meters or something.
                maxDistance: 100,
                finisher: false, // if finished will the win?
                buttonPushed: true, // if true, they will try and run, if false, then no
                canRun:true, // if true, then this player can run the relay race
                drawOtherPlayers: true
            },
            player2 : {
                X: 250,
                targetX: 250, // the X where we WANT the player drawn
                Y: 520, // hard coded Y values, since... they never change
                name: "INT",
                action: "idle", // idle, mark, set or running
                runAnimCounter: 0, // which frame of runANim to use if rnning
                distance: 100, //"distance" player has run in like, meters or something.
                maxDistance: 200,
                finisher: false, // if finished will the win?
                buttonPushed: true, // if true, they will try and run, if false, then no
                canRun:false,
                drawOtherPlayers: true
            },
            player3 : {
                X: 250,
                targetX: 250, // the X where we WANT the player drawn
                Y: 620, // hard coded Y values, since... they never change
                name: "IT",
                action: "idle", // idle, mark, set or running
                runAnimCounter: 0, // which frame of runANim to use if rnning
                distance: 200, //"distance" player has run in like, meters or something.
                maxDistance: 300,
                finisher: false, // if finished will the win?
                buttonPushed: true, // if true, they will try and run, if false, then no
                canRun: false,
                drawOtherPlayers: false
            },
        };
        const initialState = JSON.parse(JSON.stringify(state));
        document.state = state; // for easy tweaking.
        //deep copy initial state
        document.initialState = initialState;


        // DRAW HELPER FUNCS
        const playerNames = ["cpu","player1","player2","player3"];
        function drawPlayer(playernum, overrideX, overrideY){
            const playername = playerNames[playernum];
            const playerState = state[playername];
            const X = overrideX ? overrideX : playerState.X;
            const Y = overrideY ? overrideY : playerState.Y;
            if(playerState.action === "running") {
                drawPlayerSprite(playernum, "run"+playerState.runAnimCounter, X, Y);
                playerState.runAnimCounter = (playerState.runAnimCounter + 1) % 6; // wrap around
            }
            else if(playerState.action === "win" || playerState.action === "lose") {
                let animCount = (~~(framenum % 4) /2);
                drawPlayerSprite(playernum, playerState.action+animCount, X,Y);

            }
            else {
                drawPlayerSprite(playernum, playerState.action, X, Y);
            }
        }

        function drawPlayerFinishLine(playerState, onend) {
            //running through finish line animation
            var intervalHandle = setInterval(()=>{
                playerState.X += 10;
                playerState.targetX = playerState.X;
                playerState.distance += 0.1;
                if(playerState.X >= 900) {
                    clearInterval(intervalHandle);
                    if(onend) onend();
                }
            }, 80);

        }

        function drawMenu(framenum) {
            ctx.fillStyle = "#1A1A1A";
            ctx.fillRect(0, 0, canvasWidth, canvasHeight);
            if(framenum % 25 === 0) state.game.menu.blinkSelection = !state.game.menu.blinkSelection;
            switch(state.game.menu.whichMenu) {
                /*****************
                 *   MAIN MENU   *
                 ****************/
                case "main": {
                    // selectedIdx sanity checks
                    if(state.game.menu.selectedIdx < 0) state.game.menu.selectedIdx = 0;
                    else if(state.game.menu.selectedIdx > 2) state.game.menu.selectedIdx = 2;

                    const middle = canvasWidth / 2 - 110;
                    ctx.font = "50px \"Press Start 2P\", Monaco, monospace";
                    ctx.fillStyle = "white";
                    ctx.textBaseline = 'middle';
                    ctx.textAlign = 'center';
                    ctx.fillText("Supply Chain",middle, 200);
                    ctx.fillText("Sprint", middle, 300);

                    ctx.font = "30px \"Press Start 2P\", Monaco, monospace";
                    // for the flashing effect, we will change the fill color to black
                    ctx.fillStyle = "white";
                    if(state.game.menu.blinkSelection && state.game.menu.selectedIdx === 0) ctx.fillStyle = "#1A1A1A";
                    ctx.fillText("1 Player", middle, 450);
                    ctx.fillStyle = "white";
                    if(state.game.menu.blinkSelection && state.game.menu.selectedIdx === 1) ctx.fillStyle = "#1A1A1A";
                    ctx.fillText("3 Player", middle, 500);
                    ctx.fillStyle = "white";
                    if(state.game.menu.blinkSelection && state.game.menu.selectedIdx === 2) ctx.fillStyle = "#1A1A1A";
                    ctx.fillText("Cheat Codes", middle, 550);

                    ctx.fillStyle = "white";
                    ctx.font = "20px \"Press Start 2P\", Monaco, monospace";
                    ctx.textAlign = 'left';
                    ctx.fillText("Coding: Daniel Beard", 50, 725);
                    ctx.textAlign = 'right';
                    ctx.fillText("Inspiration: Josh Corman ", canvasWidth - 220, 725);
                break;
                }
                /*****************
                 *   CHEATS MENU *
                 ****************/
                case "cheats":{
                    // selectedCol sanity checks
                    if(state.game.menu.selectedCol < -1) state.game.menu.selectedCol = -1;
                    else if(state.game.menu.selectedCol > 3) state.game.menu.selectedCol = 3;

                    // cheat letter select logic
                    if(state.game.menu.selectedIdx !== 0) {
                        let col = state.game.menu.selectedCol;
                        let letter = alphabet.indexOf(state.game.menu.currentCheat[col]);
                        letter = letter + state.game.menu.selectedIdx;
                        state.game.menu.selectedIdx = 0; // reset to 0
                        if(letter < 0) letter = alphabet.length - 1; // negative wrap around
                        else if(letter >= alphabet.length) letter = letter % alphabet.length; // positive wrap around
                        // set the letter in the cheat code
                        state.game.menu.currentCheat[col] = alphabet[letter];
                    }
                    ctx.font = "50px \"Press Start 2P\", Monaco, monospace";
                    ctx.fillStyle = "white";
                    ctx.textBaseline = 'middle';
                    ctx.textAlign = 'center';
                    if(state.game.menu.blinkSelection && state.game.menu.selectedCol === -1) ctx.fillStyle = "#1A1A1A";
                    ctx.fillText("BACK", 150, 100);
                    const currentCheat = state.game.menu.currentCheat;

                    ctx.fillStyle = "white";
                    if(state.game.menu.selectedCol === 0) {
                        drawSprite(arrowUpSprite, 425, 115, 0, 0, 180, 190, 0.5);
                        drawSprite(arrowDownSprite, 425, 230, 0, 0, 180, 190, 0.5);
                        if(state.game.menu.blinkSelection) ctx.fillStyle = "#1A1A1A";
                    }
                    ctx.fillText(currentCheat[0], 450, 200);

                    ctx.fillStyle = "white";
                    if(state.game.menu.selectedCol === 1){
                        drawSprite(arrowUpSprite, 525, 115, 0, 0, 180, 190, 0.5);
                        drawSprite(arrowDownSprite, 525, 230, 0, 0, 180, 190, 0.5);
                        if(state.game.menu.blinkSelection) ctx.fillStyle = "#1A1A1A";
                    }
                    ctx.fillText(currentCheat[1], 550, 200);

                    ctx.fillStyle = "white";
                    if(state.game.menu.selectedCol === 2){
                        drawSprite(arrowUpSprite, 625, 115, 0, 0, 180, 190, 0.5);
                        drawSprite(arrowDownSprite, 625, 230, 0, 0, 180, 190, 0.5);
                        if(state.game.menu.blinkSelection) ctx.fillStyle = "#1A1A1A";
                    }
                    ctx.fillText(currentCheat[2], 650, 200);

                    ctx.fillStyle = "white";
                    if(state.game.menu.selectedCol === 3){
                        drawSprite(arrowUpSprite, 725, 115, 0, 0, 180, 190, 0.5);
                        drawSprite(arrowDownSprite, 725, 230, 0, 0, 180, 190, 0.5);
                        if(state.game.menu.blinkSelection) ctx.fillStyle = "#1A1A1A";
                    }

                    ctx.fillText(currentCheat[3], 750, 200);

                    ctx.fillStyle = "white";
                    ctx.textAlign = 'left';
                    ctx.fillText(state.game.menu.cheatStatus, 250, 400);

                    ctx.font = "20px \"Press Start 2P\", Monaco, monospace";

                    ctx.fillText("Try the following Cheat Codes: ", 150, 500);
                    ctx.fillText("_CVD  = Coordinated Vulnerability Disclosure", 200, 550);
                    ctx.fillText("SBOM  = Software Bill of Materials", 200, 600);

                }
                break;
            }

        }

        // MAIN DRAW FUNC
        function draw() {
            framenum++;
            framenum = framenum % 1000; // 1000 options to slow frames down
            // schedule nex draw
            window.requestAnimationFrame(draw);
            if(state.game.state === "menu" && framenum % 2 === 0) {
                gamepadLogic();

                ctx.clearRect(0, 0, canvasWidth, canvasHeight); // clear canvas
                drawMenu(framenum);
                if(document.drawCrt) document.drawCrt();
            }
            if(state.game.state !== "menu" && framenum % 3 === 0) {
                //draw logic
                gamepadLogic();
                ctx.clearRect(0, 0, canvasWidth, canvasHeight); // clear canvas

                    drawBackground();
                    drawPlayer(0);
                    drawPlayer(1);
                    drawPlayer(2);
                    drawPlayer(3);
                if(document.drawCrt) document.drawCrt();

                // Game logic

                //CPU move
                if(state.game.state === "game") {

                    // smooth animaton
                    if(state.cpu.targetX > state.cpu.X) state.cpu.X+=15;
                    else if(state.cpu.targetX < state.cpu.X) state.cpu.X--;

                    if(state.player1.targetX > state.player1.X) state.player1.X+=15;
                    else if(state.player1.targetX < state.player1.X) state.player1.X--;

                    if(state.player2.targetX > state.player2.X) state.player2.X+=15;
                    else if(state.player2.targetX < state.player2.X) state.player2.X--;

                    if(state.player3.targetX > state.player3.X) state.player3.X+=15;
                    else if(state.player3.targetX < state.player3.X) state.player3.X--;

                    const cpuDistLeft = (state.cpu.maxDistance - state.cpu.distance);

                    //move player if buttons pushed
                    if(state.player1.canRun && state.player1.distance < state.player1.maxDistance) {
                        if(state.player1.buttonPushed) state.player1.distance +=0.70;
                        state.player1.distance +=0.05;
                        state.player1.targetX = (state.player1.maxDistance - state.player1.distance) < cpuDistLeft ? 750 : 250 ;
                        state.player1.action = "running";
                        state.player1.buttonPushed = false;

                    }

                    if(state.player2.canRun && state.player2.distance < state.player2.maxDistance) {
                        if(state.player2.buttonPushed) state.player2.distance +=0.50;
                        state.player2.distance +=0.10;
                        state.player2.targetX = (state.player2.maxDistance - state.player2.distance) < cpuDistLeft ? 750 : 250 ;
                        state.player2.action = "running";
                        state.player2.buttonPushed = false;

                    }

                    if(state.player3.canRun && state.player3.distance < state.player3.maxDistance) {
                        if(state.player3.buttonPushed) state.player3.distance +=0.50;
                        state.player3.distance +=0.10;
                        state.player3.targetX = (state.player3.maxDistance - state.player3.distance) < cpuDistLeft ? 750 : 250 ;
                        state.player3.action = "running";
                        state.player3.buttonPushed = false;
                    }

                    //move CPU
                    if(state.cpu.canRun && state.cpu.distance < state.cpu.maxDistance) state.cpu.distance +=0.15;
                    //lose condition
                    else if(state.cpu.distance >= state.cpu.maxDistance) state.game.state = "lose";
                    //only win if player 3 is at the max
                    if(state.player3.distance >= state.player3.maxDistance) state.game.state = "win";

                    //stop player 1 and player 2 if they're at max distance, no run animation
                    if(state.player1.canRun && state.player1.distance >= state.player1.maxDistance)  {
                        state.player1.canRun = false;
                        drawPlayerFinishLine(state.player1, ()=> state.player1.action = "idle");
                        state.player2.canRun = true; // relay off to player 2
                    }
                    if( state.player2.canRun && state.player2.distance >= state.player2.maxDistance)  {
                        state.player2.canRun = false;
                        drawPlayerFinishLine(state.player2, ()=> state.player2.action = "idle");
                        state.player3.canRun = true; // relay off to player 3
                    }
                }
                else if(state.game.state === "lose") {

                    drawPlayerFinishLine(state.cpu, ()=> {
                        state.cpu.action = "win";
                        state.game.state = "end";
                    });

                    document.getElementById("sndlose").play();
                    setAllPlayerStates("action", "lose");
                    state.cpu.action = "running"; // he's still running thru the finish line
                    document.getElementById("sndrun").pause();

                }
                else if (state.game.state === "win") {
                    drawPlayerFinishLine(state.player3, ()=> {
                        state.player1.action = "win";
                        state.player2.action = "win";
                        state.player3.action = "win";
                        state.game.state = "end";
                    });
                    document.getElementById("sndwin").play();
                    setAllPlayerStates("action", "win");
                    //except CPU who loses
                    state.cpu.action = "lose";
                    state.player3.action = "running";

                    document.getElementById("sndrun").pause();
                }
                else if(state.game.state === "reset") {
                    state = JSON.parse(JSON.stringify(initialState));
                    document.state = state;
                }
            }

        }

        draw();

    }

    init();

    // logic for starting the game itself
    function startGame(state) {
        state.game.state = "prep";
        document.getElementById("sndtitle").pause();
        document.getElementById("sndstart").play();
        setTimeout(()=>{ setAllPlayerStates("action", "mark"); document.getElementById("sndbeep").play(); }, 6000);
        setTimeout(()=>{ setAllPlayerStates("action", "set"); document.getElementById("sndbeep").play(); }, 8000);
        setTimeout(()=>{
            setTimeout(()=> {
                state.cpu.action="running"; // CPU is LIGHTNING FAST
                state.cpu.targetX= 500; // CPU is LIGHTNING FAST
                state.cpu.canRun = true;
            }, state.game.cpuHeadStart);
            state.game.state = "game";
            document.getElementById("sndgun").play();
            setTimeout(()=>document.getElementById("sndrun").play(), 500);
        }, 10000);
    }
    // logic for selection made in the menus (e.g. A button pushed)
    function selectionMade(state) {
        if(state.game.state === "menu") {
            if(state.game.menu.whichMenu === "main"){
                switch(state.game.menu.selectedIdx) {
                    case 0:
                        state.game.players = 1;
                        return startGame(state);
                    case 1:
                        state.game.players = 3;
                        return startGame(state);
                    case 2:
                        state.game.menu.whichMenu = "cheats";
                        state.game.menu.currentCheat =  ["A","A","A","A"];
                        state.game.menu.selectedCol = 0;
                        state.game.menu.selectedIdx = 0;
                        return;
                }
            }
            else if(state.game.menu.whichMenu === "cheats"){
                if(state.game.menu.selectedCol === -1) {
                    state.game.menu.whichMenu = "main";
                    state.game.menu.selectedCol = 0;
                    state.game.menu.selectedIdx = 0;
                }else {
                    // CHEATS LOGIC
                    const currentCode = state.game.menu.currentCheat.join("");
                    let succ = false;
                    switch(currentCode){
                        case "_CVD":
                            succ = true;
                            state.game.cpuHeadStart = 15000;
                        break;
                        case "SBOM":
                            succ = true;
                            setAllPlayerStates("canRun", true);
                        break;
                    }
                    if(succ) state.game.menu.cheatStatus = currentCode + " SUCCESS ";
                    else state.game.menu.cheatStatus = currentCode + " FAILED ";
                }

            }
        }
    }

    function setAllPlayerStates(key, val) {
        document.state.cpu[key] = val;
        document.state.player1[key] = val;
        document.state.player2[key] = val;
        document.state.player3[key] = val;
    }
    document.addEventListener('keydown', function(event) {
        const state = document.state;
        console.log(event.key)
       switch(event.key) {
         case " ":
             if(state.game.state === "idle") {
                 startGame(state);
             } else if(state.game.state === "end") {
                    state.game.state = "reset";
                    document.getElementById("sndtitle").play();
             }
         break;
             case "ArrowUp":
                 state.game.menu.selectedIdx--;
             break;
             case "ArrowDown":
                 state.game.menu.selectedIdx++;
             break;
           case "ArrowLeft":
               state.game.menu.selectedCol--;
               break;
           case "ArrowRight":
               state.game.menu.selectedCol++;
               break;
             case "Enter":
                 selectionMade(state);
             break;

       }
    });

    //gamepad support
    window.addEventListener("gamepadconnected", (event) => {
        console.log("A gamepad connected:");
        console.log(event.gamepad);
    });

    let buttonLastStatus = [Array(16).fill(false), Array(16).fill(false), Array(16).fill(false)];
    let lastRunButtonPushed = ["B","B","B"];
    function gamepadLogic() {
        var gamepads = navigator.getGamepads();
        // a button is "pushed" if it's last status was true(depressed) but is now false (released)
        // in this way we only react when your finger is taken off of the button
        let buttonsPushed = [Array(16).fill(false), Array(16).fill(false), Array(16).fill(false)];

        //P1 menu selection logic
        let state = document.state;
        for(let i=0; i<3; i++)  {
            if(gamepads[i] && gamepads[i].buttons){
                for(let j=0; j<16; j++) {
                    // see above note for logic with buttojn "pushing"
                    if( buttonLastStatus[i][j] && !gamepads[i].buttons[j].pressed) buttonsPushed[i][j] = true;
                    buttonLastStatus[i][j] = gamepads[i].buttons[j].pressed;
                }
            }
        }

        if(state.game.state === "menu") {
            // B button
            if(buttonsPushed[0][0]) state.game.menu.whichMenu = "main"; // back to main menu
            // A button
            else if(buttonsPushed[0][1]) selectionMade(state);
            // up DPAD
            else if(buttonsPushed[0][12]) state.game.menu.selectedIdx--;
            // down DPAD
            else if(buttonsPushed[0][13]) state.game.menu.selectedIdx++;
            // left DPAD
            else if(buttonsPushed[0][14]) state.game.menu.selectedCol--;
            // right DPAD
            else if(buttonsPushed[0][15]) state.game.menu.selectedCol++;

        }
        else if(state.game.state === "end") {
            //reset
            for(let i=0; i<3; i++) {
                // start button
                if (buttonsPushed[i][9]) {
                    state.game.state = "reset";
                    document.getElementById("sndtitle").play();
                }
            }
        }  else {

            for(let i=0; i<3; i++) {

                if(buttonsPushed[i][0]) {
                    if(lastRunButtonPushed[i] === "A") setAllPlayerStates("buttonPushed", true);
                    lastRunButtonPushed[i] = "B";
                    console.log("b")
                }
                else if(buttonsPushed[i][1]) {
                    if(lastRunButtonPushed[i] === "B") setAllPlayerStates("buttonPushed", true);
                    lastRunButtonPushed[i] = "A";
                    console.log("A")
                }
            }
        }

    }

</script>
<!-- CRT screen effect -->
<script src="js/glfx.js"> </script>
<script src="js/crt.js"> </script>

</body>
</html>
